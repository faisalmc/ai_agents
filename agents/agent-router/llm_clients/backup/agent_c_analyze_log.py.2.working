# agent_c_analyze_log.py
# Author: Faisal Chaudhry
# Purpose: Analyze device log and respond to Slack /analyze-log (via Socket Mode)

import os
import json
from datetime import datetime
import threading
from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from llm_api import call_llm

# --- Config
SLACK_BOT_TOKEN = os.getenv("SLACK_BOT_TOKEN")
SLACK_APP_TOKEN = os.getenv("SLACK_APP_TOKEN")
SLACK_CHANNEL = os.getenv("SLACK_CHANNEL", "general")  #  Must be without '#'

app = App(token=SLACK_BOT_TOKEN)
client = WebClient(token=SLACK_BOT_TOKEN)


def extract_error_context(log_path, before=10, after=10):
    with open(log_path, "r") as f:
        lines = f.readlines()

    error_blocks = []
    for i, line in enumerate(lines):
        if "Invalid input" in line or "^" in line:
            start = max(i - before, 0)
            end = min(i + after + 1, len(lines))
            error_blocks.append("".join(lines[start:end]))

    return error_blocks


def analyze_log_with_llm(error_context, full_log_text):
    system_prompt = (
        "You are a Cisco-certified expert (CCIE-SP level). "
        "Analyze router CLI logs (IOS, IOS-XR). Identify CLI/commit errors, diagnose causes, "
        "and suggest correct configurations. Avoid hallucinations. Use accurate terminology."
    )

    few_shot_examples = [
        {
            "role": "user",
            "content": "Log: interface GigabitEthernet0/0/0\nipv6 address 2001:db8::1/64\n^",
        },
        {
            "role": "assistant",
            "content": json.dumps({
                "issue": "Invalid syntax in IOS-XR IPv6 config.",
                "explanation": "Caret (^) indicates syntax error. IOS-XR expects 'ipv6 address' under a submode.",
                "recommendation": "Ensure correct nesting or use 'address' instead of 'ipv6 address'.",
                "confidence": "low",
                "needs_more_context": True
            }, indent=2)
        }
    ]

    messages = [{"role": "system", "content": system_prompt}] + few_shot_examples

    if error_context:
        messages.append({
            "role": "user",
            "content": f"Analyze the following CLI log snippet:\n\n{error_context}\n\nOnly explain what is visible. Do not assume unseen configuration."
        })
        messages.append({
            "role": "user",
            "content": "Important: Do not invent missing config lines. Focus only on the lines present. If something seems missing, say 'unclear due to partial context'."
        })

    print("[DEBUG] Sending error snippet to LLM", flush=True)
    partial_result = call_llm(messages)
    print("[DEBUG] Initial LLM output (error context only):", flush=True)
    print(partial_result, flush=True)

    print("[DEBUG] Sending full log to LLM", flush=True)
    messages.append({
        "role": "user",
        "content": (
            f"Now, based only on the log below, return a valid JSON object with these fields:\n"
            f"- issue (string)\n- explanation (string)\n- recommendation (string)\n"
            f"- confidence (low/medium/high)\n- needs_more_context (true/false)\n\n"
            f"Ensure the output is a single valid JSON object and nothing else.\n\n"
            f"Full Log:\n{full_log_text[:10000]}"
        )
    })

    final_result = call_llm(messages)
    print("[DEBUG] Final LLM output (full log):", flush=True)
    print(final_result, flush=True)

    return final_result  # Return final result only


# def post_to_slack(summary_json, task_path, task_name, hostname):
#     json_path = os.path.join("/tmp", f"{hostname}-analysis.json")
#     with open(json_path, "w") as f:
#         json.dump(summary_json, f, indent=2)

#     timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')
#     text_summary = f"""
# *Log Analysis for* `{hostname}`
# • Task: `{task_name}`
# • Path: `{task_path}`
# • Timestamp: `{timestamp}`
# • Issue: `{summary_json.get("issue", "No issue reported")}`
# • Explanation: `{summary_json.get("explanation", "N/A")}`
# • Recommendation: `{summary_json.get("recommendation", "N/A")}`
# • Confidence: `{summary_json.get("confidence", "unknown")}`
# • Needs More Context: `{summary_json.get("needs_more_context", False)}`
# """

#     try:
#         print(f"[DEBUG] Posting summary for {hostname} to Slack", flush=True)
#         client.chat_postMessage(channel=SLACK_CHANNEL, text=text_summary)
#         client.files_upload_v2(
#             channel=SLACK_CHANNEL,
#             file=json_path,
#             title=f"{hostname}-analysis.json",
#             filename=f"{hostname}-analysis.json",
#             initial_comment="Detailed JSON result attached."
#         )
#     except SlackApiError as e:
#         print(f"[SlackError] {e.response['error']}", flush=True)

def post_to_slack(summary_json, task_path, task_name, hostname, channel_id):
    json_path = os.path.join("/tmp", f"{hostname}-analysis.json")
    with open(json_path, "w") as f:
        json.dump(summary_json, f, indent=2)

    timestamp = datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')
    text_summary = f"""
*Log Analysis for* `{hostname}`
• Task: `{task_name}`
• Path: `{task_path}`
• Timestamp: `{timestamp}`
• Issue: `{summary_json.get("issue", "No issue reported")}`
• Explanation: `{summary_json.get("explanation", "N/A")}`
• Recommendation: `{summary_json.get("recommendation", "N/A")}`
• Confidence: `{summary_json.get("confidence", "unknown")}`
• Needs More Context: `{summary_json.get("needs_more_context", False)}`
"""

    try:
        print(f"[DEBUG] Posting summary for {hostname} to Slack", flush=True)
        client.chat_postMessage(channel=channel_id, text=text_summary)
        client.files_upload_v2(
            channel=channel_id,
            file=json_path,
            title=f"{hostname}-analysis.json",
            filename=f"{hostname}-analysis.json",
            initial_comment="Detailed JSON result attached."
        )
    except SlackApiError as e:
        print(f"[SlackError] {e.response['error']}", flush=True)

# def analyze_log_entry(task_path, task_name, hostname):
#     log_path = os.path.join("/app/doo", task_path, task_name, "logs", f"{hostname}.log")
#     print(f"[DEBUG] Looking for log at: {log_path}", flush=True)

#     if not os.path.exists(log_path):
#         print(f"[ERROR] Log not found: {log_path}", flush=True)
#         return

#     with open(log_path, "r") as f:
#         full_log = f.read()

#     error_context = "\n\n".join(extract_error_context(log_path))

#     final_result = analyze_log_with_llm(error_context, full_log)

#     try:
#         summary = json.loads(final_result)
#         print("[DEBUG] Parsed valid JSON from LLM.", flush=True)
#     except json.JSONDecodeError as e:
#         print(f"[ERROR] Could not parse JSON from LLM: {e}", flush=True)
#         summary = {
#             "issue": "LLM output not in JSON format",
#             "explanation": "",
#             "recommendation": "",
#             "confidence": "unknown",
#             "needs_more_context": True,
#             "raw_response": final_result
#         }

#     post_to_slack(summary, task_path, task_name, hostname)

def analyze_log_entry(task_path, task_name, hostname, channel_id):
    log_path = os.path.join("/app/doo", task_path, task_name, "logs", f"{hostname}.log")
    print(f"[DEBUG] Looking for log at: {log_path}", flush=True)

    if not os.path.exists(log_path):
        print(f"[ERROR] Log not found: {log_path}", flush=True)
        return

    with open(log_path, "r") as f:
        full_log = f.read()

    error_context = "\n\n".join(extract_error_context(log_path))

    final_result = analyze_log_with_llm(error_context, full_log)

    try:
        summary = json.loads(final_result)
        print("[DEBUG] Parsed valid JSON from LLM.", flush=True)
    except json.JSONDecodeError as e:
        print(f"[ERROR] Could not parse JSON from LLM: {e}", flush=True)
        summary = {
            "issue": "LLM output not in JSON format",
            "explanation": "",
            "recommendation": "",
            "confidence": "unknown",
            "needs_more_context": True,
            "raw_response": final_result
        }

    post_to_slack(summary, task_path, task_name, hostname, channel_id)

@app.command("/analyze-log")
def handle_analyze_log(ack, respond, command):
    # ack()
    try:
        ack({"response_type": "ephemeral", "text": "Analyzing log... Please wait ⏳"})
    except Exception as e:
        print(f"[ERROR] Failed to ack: {e}", flush=True)
        return

    try:
        args = command.get("text", "").strip().split()
        print(f"[DEBUG] Received /analyze-log args: {args}", flush=True)

        if len(args) != 3:
            respond("Usage: /analyze-log <hostname> <config_dir> <task_dir>")
            return

        hostname, config_dir, task_dir = args
        channel_id = command["channel_id"]  # use this
        respond(f"Started analysis for {hostname}. Result will be posted to Slack.")

        def run_analysis():
            try:
                print(f"[DEBUG] Background thread started for {hostname}", flush=True)
                analyze_log_entry(config_dir, task_dir, hostname, channel_id)  # ✅ pass it
                print(f"[DEBUG] Analysis complete for {hostname}", flush=True)
            except Exception as thread_err:
                print(f"[ERROR] Exception in background thread: {thread_err}", flush=True)

        threading.Thread(target=run_analysis).start()

    except Exception as e:
        print(f"[ERROR] Exception in /analyze-log: {e}", flush=True)
        try:
            respond(f"Exception occurred: {e}")
        except:
            print(f"[WARN] Could not send error to Slack", flush=True)

# @app.command("/analyze-log")
# def handle_analyze_log(ack, body, say, logger):
#     ack()

#     # Parse command text
#     args = body.get("text", "").strip().split()
#     logger.info(f"Args: {args}")

#     if len(args) != 3:
#         say("Usage: /analyze-log <hostname> <config_dir> <task_dir>")
#         return

#     hostname, config_dir, task_dir = args
#     channel_id = body.get("channel_id")

#     # Background processing
#     def run():
#         try:
#             analyze_log_entry(config_dir, task_dir, hostname, channel_id)
#         except Exception as e:
#             logger.error(f"Thread error: {e}")
#             say(f"Analysis failed for {hostname}")

#     import threading
#     threading.Thread(target=run).start()


if __name__ == "__main__":
    print("[DEBUG] Agent-C is running...", flush=True)
    SocketModeHandler(app, SLACK_APP_TOKEN).start()
